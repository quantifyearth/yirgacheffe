{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#overview","title":"Overview","text":"<p>Yirgacheffe is a Python library that provides a declarative way of working with geospatial data, taking care of all the tedious tasks of aligning rasters, rasterizing polygons, and dealing with memory management and other hardware management issues. You can think of it as numpy or pandas but for geospatial data. Here's a quick example of calculating a species Area Of Habitat using Yirgacheffe:</p> <pre><code>import yirgaceffe as yg\n\nwith (\n    yg.read_raster(\"habitats.tif\") as habitat_map,\n    yg.read_raster('elevation.tif') as elevation_map,\n    yg.read_shape('species123.geojson') as range_map,\n):\n    refined_habitat = habitat_map.isin([...species habitat codes...])\n    refined_elevation = (elevation_map &gt;= species_min) &amp; (elevation_map &lt;= species_max)\n    aoh = refined_habitat * refined_elevation * range_polygon * area_per_pixel_map\n    print(f'Area of habitat: {aoh.sum()}')\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<p>Yirgacheffe is available via pypi, so can be installed with pip for example:</p> <pre><code>$ pip install yirgacheffe\n</code></pre>"},{"location":"#basic-features","title":"Basic features","text":""},{"location":"#layers","title":"Layers","text":"<p>They main unit of data in Yirgacheffe is a \"layer\", which wraps either a raster dataset or polygon data, and then you can do work on layers without having to worry (unless you choose to) about how they align. Yirgacheffe will automatically infer if you want to do an intersection of maps or a union of the maps based on the operators you use (see below for a full table). You can explicitly override that if you want.</p>"},{"location":"#expressions-on-layers","title":"Expressions on layers","text":"<p>Rather than working with arrays of pixel values as you would with say GDAL, Yirgacheffe lets you directly operate on layers without having to worry about reading and writing the individual values within.</p>"},{"location":"#lazy-loading-and-evaluation","title":"Lazy loading and evaluation","text":"<p>Yirgacheffe uses a technique from computer science called \"lazy evaluation\", which means that only when you resolve a calculation will Yirgacheffe do any work. So in the first code example given, the work is only calculated when you call the <code>sum()</code> method. All the other intermediary results such as <code>refined_habitat</code> and <code>refined_elevation</code> are not calculated either until that final <code>sum()</code> is called. You could easily call sum on those intermediaries if you wanted and get their results, and that would cause them to be evaluated then.</p> <p>Similarly, when you load a layer, be it a raster layer or a vector layer from polygon data, the full data for the file isn't loaded until it's needed for a calculation, and even then only the part of the data necessary will be loaded or rasterized. Furthermore, Yirgacheffe will load the data in chunks, letting you work with rasters bigger than those that would otherwise fit within your computer's memory.</p>"},{"location":"#automatic-expanding-and-contracting-layers","title":"Automatic expanding and contracting layers","text":"<p>When you load raster layers that aren't of equal geographic area (that is, they have a different origin, size, or both)then Yirgacheffe will do all the math internally to ensure that it aligns the pixels geospatially when doing calculations.</p> <p>If size adjustments are needed, then Yirgacheffe will infer from the calculations you're doing if it needs to either crop or enlarge layers. For instance, if you're summing two rasters it'll expand them to be the union of their two areas before adding them, filling in the missing parts with zeros. If you're multiplying or doing a logical AND of pixels then it'll find the intersection between the two rasters (as areas missing in one would cause the other layer to result in zero anyway).</p>"},{"location":"#direct-access-to-data","title":"Direct access to data","text":"<p>If doing per-layer operations isn't applicable for your application, you can read the pixel values for all layers (including VectorLayers) by calling <code>read_array</code> similarly to how you would for GDAL.</p>"},{"location":"#parallel-saving","title":"Parallel saving","text":"<p>There is a parallel version of save that can use multiple CPU cores at once to speed up work, that is added as an experimental feature for testing in our wider codebase, which will run concurrently the save over many threads.</p>"},{"location":"#gpu-support","title":"GPU support","text":"<p>Yirgacheffe has multiple backends, with more planned. Currently you can set the <code>YIRGACHEFFE_BACKEND</code> environmental variable to select which one to use. The default is <code>NUMPY</code>:</p> <ul> <li><code>NUMPY</code>: CPU based calculation using numpy</li> <li><code>MLX</code>: Apple/Intel GPU support with CPU fallback based on MLX</li> </ul> <p>Note that GPU isn't always faster than CPU - it very much depends on the workload, so testing your particular use-case is important.</p>"},{"location":"#citation","title":"Citation","text":"<p>If you use Yirgacheffe in your research, please cite our paper:</p> <p>Michael Winston Dales, Alison Eyres, Patrick Ferris, Francesca A. Ridley, Simon Tarr, and Anil Madhavapeddy. 2025. Yirgacheffe: A Declarative Approach to Geospatial Data. In Proceedings of the 2nd ACM SIGPLAN International Workshop on Programming for the Planet (PROPL '25). Association for Computing Machinery, New York, NY, USA, 47\u201354. https://doi.org/10.1145/3759536.3763806</p> BibTeX <pre><code>@inproceedings{10.1145/3759536.3763806,\n  author = {Dales, Michael Winston and Eyres, Alison and Ferris, Patrick and Ridley, Francesca A. and Tarr, Simon and Madhavapeddy, Anil},\n  title = {Yirgacheffe: A Declarative Approach to Geospatial Data},\n  year = {2025},\n  isbn = {9798400721618},\n  publisher = {Association for Computing Machinery},\n  address = {New York, NY, USA},\n  url = {https://doi.org/10.1145/3759536.3763806},\n  doi = {10.1145/3759536.3763806},\n  abstract = {We present Yirgacheffe, a declarative geospatial library that allows spatial algorithms to be implemented concisely, supports parallel execution, and avoids common errors by automatically handling data (large geospatial rasters) and resources (cores, memory, GPUs). Our primary user domain comprises ecologists, where a typical problem involves cleaning messy occurrence data, overlaying it over tiled rasters, combining layers, and deriving actionable insights from the results. We describe the successes of this approach towards driving key pipelines related to global biodiversity and describe the capability gaps that remain, hoping to motivate more research into geospatial domain-specific languages.},\n  booktitle = {Proceedings of the 2nd ACM SIGPLAN International Workshop on Programming for the Planet},\n  pages = {47\u201354},\n  numpages = {8},\n  keywords = {Biodiversity, Declarative, Geospatial, Python},\n  location = {Singapore, Singapore},\n  series = {PROPL '25}\n}\n</code></pre>"},{"location":"#about","title":"About","text":"<p>Yirgacheffe was created by Michael Dales whilst working on multiple geospatial projects as a way to hide the boilerplate associated with working with large raster and polygon geospatial datasets.</p> <p>The code for Yirgcheffe is available on Github.</p>"},{"location":"CODE_OF_CONDUCT/","title":"Contributor Covenant 3.0 Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We pledge to make our community welcoming, safe, and equitable for all.</p> <p>We are committed to fostering an environment that respects and promotes the dignity, rights, and contributions of all individuals, regardless of characteristics including race, ethnicity, caste, colour, age, physical characteristics, neurodiversity, disability, sex or gender, gender identity or expression, sexual orientation, language, philosophy or religion, national or social origin, socio-economic position, level of education, or other status. The same privileges of participation are extended to everyone who participates in good faith and in accordance with this Covenant.</p>"},{"location":"CODE_OF_CONDUCT/#encouraged-behaviours","title":"Encouraged Behaviours","text":"<p>While acknowledging differences in social norms, we all strive to meet our community's expectations for positive behaviour. We also understand that our words and actions may be interpreted differently than we intend based on culture, background, or native language.</p> <p>With these considerations in mind, we agree to behave mindfully toward each other and act in ways that centre our shared values, including:</p> <ol> <li>Respecting the purpose of our community, our activities, and our ways of gathering.</li> <li>Engaging kindly and honestly with others.</li> <li>Respecting different viewpoints and experiences.</li> <li>Taking responsibility for our actions and contributions.</li> <li>Gracefully giving and accepting constructive feedback.</li> <li>Committing to repairing harm when it occurs.</li> <li>Behaving in other ways that promote and sustain the well-being of our community.</li> </ol>"},{"location":"CODE_OF_CONDUCT/#restricted-behaviours","title":"Restricted Behaviours","text":"<p>We agree to restrict the following behaviours in our community. Instances, threats, and promotion of these behaviors are violations of this Code of Conduct.</p> <ol> <li>Harassment. Violating explicitly expressed boundaries or engaging in unnecessary personal attention after any clear request to stop.</li> <li>Character attacks. Making insulting, demeaning, or pejorative comments directed at a community member or group of people.</li> <li>Stereotyping or discrimination. Characterising anyone\u2019s personality or behaviour on the basis of immutable identities or traits.</li> <li>Sexualization. Behaving in a way that would generally be considered inappropriately intimate in the context or purpose of the community.</li> <li>Violating confidentiality. Sharing or acting on someone's personal or private information without their permission.</li> <li>Endangerment. Causing, encouraging, or threatening violence or other harm toward any person or group.</li> <li>Behaving in other ways that threaten the well-being of our community.</li> </ol>"},{"location":"CODE_OF_CONDUCT/#other-restrictions","title":"Other Restrictions","text":"<ol> <li>Misleading identity. Impersonating someone else for any reason, or pretending to be someone else to evade enforcement actions.</li> <li>Failing to credit sources. Not properly crediting the sources of content you contribute.</li> <li>Promotional materials. Sharing marketing or other commercial content in a way that is outside the norms of the community.</li> <li>Irresponsible communication. Failing to responsibly present content which includes, links or describes any other restricted behaviors.</li> </ol>"},{"location":"CODE_OF_CONDUCT/#reporting-an-issue","title":"Reporting an Issue","text":"<p>Tensions can occur between community members even when they are trying their best to collaborate. Not every conflict represents a code of conduct violation, and this Code of Conduct reinforces encouraged behaviours and norms that can help avoid conflicts and minimise harm.</p> <p>When an incident does occur, it is important to report it promptly. To report a possible violation, contact the lead project maintainer, Michael Dales, @mdales on github, or mwd24@cam.ac.uk by email.</p> <p>Community Moderators take reports of violations seriously and will make every effort to respond in a timely manner. They will investigate all reports of code of conduct violations, reviewing messages, logs, and recordings, or interviewing witnesses and other participants. Community Moderators will keep investigation and enforcement actions as transparent as possible while prioritising safety and confidentiality. In order to honour these values, enforcement actions are carried out in private with the involved parties, but communicating to the whole community may be part of a mutually agreed upon resolution.</p>"},{"location":"CODE_OF_CONDUCT/#addressing-and-repairing-harm","title":"Addressing and Repairing Harm","text":"<p>If an investigation by the Community Moderators finds that this Code of Conduct has been violated, the following enforcement ladder may be used to determine how best to repair harm, based on the incident's impact on the individuals involved and the community as a whole. Depending on the severity of a violation, lower rungs on the ladder may be skipped.</p> <p>1) Warning    1) Event: A violation involving a single incident or series of incidents.    2) Consequence: A private, written warning from the Community Moderators.    3) Repair: Examples of repair include a private written apology, acknowledgement of responsibility, and seeking clarification on expectations. 2) Temporarily Limited Activities    1) Event: A repeated incidence of a violation that previously resulted in a warning, or the first incidence of a more serious violation.    2) Consequence: A private, written warning with a time-limited cooldown period designed to underscore the seriousness of the situation and give the community members involved time to process the incident. The cooldown period may be limited to particular communication channels or interactions with particular community members.    3) Repair: Examples of repair may include making an apology, using the cooldown period to reflect on actions and impact, and being thoughtful about re-entering community spaces after the period is over. 3) Temporary Suspension    1) Event: A pattern of repeated violation which the Community Moderators have tried to address with warnings, or a single serious violation.    2) Consequence: A private written warning with conditions for return from suspension. In general, temporary suspensions give the person being suspended time to reflect upon their behaviour and possible corrective actions.    3) Repair: Examples of repair include respecting the spirit of the suspension, meeting the specified conditions for return, and being thoughtful about how to reintegrate with the community when the suspension is lifted. 4) Permanent Ban    1) Event: A pattern of repeated code of conduct violations that other steps on the ladder have failed to resolve, or a violation so serious that the Community Moderators determine there is no way to keep the community safe with this person as a member.    2) Consequence: Access to all community spaces, tools, and communication channels is removed. In general, permanent bans should be rarely used, should have strong reasoning behind them, and should only be resorted to if working through other remedies has failed to change the behaviour.    3) Repair: There is no possible repair in cases of this severity.</p> <p>This enforcement ladder is intended as a guideline. It does not limit the ability of Community Managers to use their discretion and judgment, in keeping with the best interests of our community.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public or other spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 3.0, permanently available at https://www.contributor-covenant.org/version/3/0/.</p> <p>Contributor Covenant is stewarded by the Organisation for Ethical Source and licensed under CC BY-SA 4.0. To view a copy of this license, visit https://creativecommons.org/licenses/by-sa/4.0/</p> <p>For answers to common questions about Contributor Covenant, see the FAQ at https://www.contributor-covenant.org/faq. Translations are provided at https://www.contributor-covenant.org/translations. Additional enforcement and community guideline resources can be found at https://www.contributor-covenant.org/resources. The enforcement ladder was inspired by the work of Mozilla\u2019s code of conduct team.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v1123-02022026","title":"v1.12.3 (02/02/2026)","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Added a <code>to_graphviz</code> call for expressions to help with debugging.</li> <li>Support sparse GeoTIFF creation.</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Ensure datatype is correctly propegated through <code>astype</code> operator.</li> </ul>"},{"location":"changelog/#v1122-2712026","title":"v1.12.2 (27/1/2026)","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Added <code>yg.sum</code>, <code>yg.all</code>, <code>yg.any</code> to build layers from lists of layers.</li> <li>Cache limits applied to GDAL and MLX which tend to assume that they are the only thing using memory. You can override these by adjusting <code>yg.constants.GDAL_CACHE_LIMIT</code> and <code>yg.constants.MLX_CACHE_LIMIT</code>.</li> </ul>"},{"location":"changelog/#v1121-2112026","title":"v1.12.1 (21/1/2026)","text":""},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Added some type checking on read_rasters due to people misunderstand the API.</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Issue found where conv2d interacted badly with group layers.</li> </ul>"},{"location":"changelog/#v1120-712026","title":"v1.12.0 (7/1/2026)","text":""},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Added new file opening <code>read_raster_like</code> that will dynamically reproject a raster to the map projection of another layer using the specified resampling method.</li> </ul>"},{"location":"changelog/#v1113-17122025","title":"v1.11.3 (17/12/2025)","text":""},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Allow <code>Area.project_like</code> to convert between projections.</li> <li>Provide a version of <code>unique</code> similar to that found in numpy.</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Fixed issue where due to GDAL behaviour layers read in with EPSG:5845 would save with an altered projection that didn't maintain quality when reloaded.</li> </ul>"},{"location":"changelog/#v1112-09122025","title":"v1.11.2 (09/12/2025)","text":""},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Fixed issue with using map projections that don't align origin with EPSG:4326.</li> </ul>"},{"location":"changelog/#v1111-01122025","title":"v1.11.1 (01/12/2025)","text":""},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Add <code>nodata</code> support to <code>to_geotiff</code>.</li> </ul>"},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>Fixed a bug whereby the grid to which polygons was rasterized would wobble depending on the context of the reading the array.</li> </ul>"},{"location":"changelog/#v1110-28112025","title":"v1.11.0 (28/11/2025)","text":""},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Ensure that nearest neighbour is applied consistently when using layers that are at the same geospatial resolution but not exactly aligned.</li> <li>Allow set operations | (union) and &amp; (intersection) on Area types.</li> </ul>"},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>Approximations used in comparing pixel scales and rounding down/up arrays are now projection aware, rather than always done in EPSG:4326.</li> <li>Fix issue with creating data layers from numpy arrays where an exception was thrown due to rounding issues on projection math.</li> </ul>"},{"location":"changelog/#v1103-10112025","title":"v1.10.3 (10/11/2025)","text":""},{"location":"changelog/#fixed_6","title":"Fixed","text":"<ul> <li>Improved consistency between Numpy and MLX backends when calling sum</li> </ul>"},{"location":"changelog/#v1102-4112025","title":"v1.10.2 (4/11/2025)","text":""},{"location":"changelog/#fixed_7","title":"Fixed","text":"<ul> <li>Detect if <code>to_geotiff</code> is being targetted at a GDAL virtual file, in which case don't use a temporary directory.</li> </ul>"},{"location":"changelog/#v1101-4112025","title":"v1.10.1 (4/11/2025)","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Added <code>sizeof</code> to the DataType enumeration to get number of bytes a given type requires.</li> </ul>"},{"location":"changelog/#v1100-1112025","title":"v1.10.0 (1/11/2025)","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Support for reverse operators, so that now you can write <code>1 + layer</code> just as you could write <code>layer + 1</code>, rather than having to cast left hand constants to <code>yg.constant(1) + layer</code></li> <li>Implemented common subexpression elimination to improve performance.</li> </ul>"},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>Area and Window @dataclass types are marked as frozen (i.e., are immutable).</li> <li>Test elements for <code>isin</code> can now include sets, not just lists and tuples.</li> </ul>"},{"location":"changelog/#fixed_8","title":"Fixed","text":"<ul> <li>Grow on Window class calculated updated y offset incorrectly, which impacted <code>conv2d</code> usage.</li> </ul>"},{"location":"changelog/#v195-25102025","title":"v1.9.5 (25/10/2025)","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Added <code>from_array</code> method to generate layer from numpy array directly.</li> </ul>"},{"location":"changelog/#v194-23102025","title":"v1.9.4 (23/10/2025)","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Exposed the callback parameter to <code>to_geotiff</code>.</li> </ul>"},{"location":"changelog/#v193-10102025","title":"v1.9.3 (10/10/2025)","text":""},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li>Unit tests now covered by mypy checks</li> <li>Exposed operator functions on top level, so you can do <code>yg.where</code> rather  than <code>yg.operators.where</code>, ready for 2.0.</li> </ul>"},{"location":"changelog/#fixed_9","title":"Fixed","text":"<ul> <li>Calling <code>show</code> with too little data gave a downsample skip of zero. Now don't downsample if data is too few.</li> </ul>"},{"location":"changelog/#v192-9102025","title":"v1.9.2 (9/10/2025)","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>Added a <code>show</code> method to layers/expressions to render them using matplotlib.</li> </ul>"},{"location":"changelog/#v191-1102025","title":"v1.9.1 (1/10/2025)","text":""},{"location":"changelog/#changed_7","title":"Changed","text":"<ul> <li>Moved <code>latlng_for_pixel</code> and <code>pixel_for_latlng</code> to <code>LayerMathMixin</code> so they can be called on expressions as well as concrete layers.</li> </ul>"},{"location":"changelog/#v190-2692025","title":"v1.9.0 (26/9/2025)","text":""},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li>Added code of conduct to project.</li> <li>Added the ability to call <code>read_array</code> on expressions (before you could only call it on layers).</li> </ul>"},{"location":"changelog/#changed_8","title":"Changed","text":"<ul> <li>The first argument of MapProjection, the string defining the projection used is now validated with the pyproj library, and can be in any from the pyproj <code>from_string</code> takes: Well Known Text (WKT) or \"epsg:4326\" or \"esri:54009\" etc. The name function still returns the WKT representation for backwards compatibility.</li> <li>The functions <code>pixel_from_latlng</code> and <code>latlng_from_pixel</code> will work regardless of the underlying map projection.</li> </ul>"},{"location":"changelog/#v181-2592025","title":"v1.8.1 (25/9/2025)","text":""},{"location":"changelog/#fixed_10","title":"Fixed","text":"<ul> <li>Fixed issue whereby calling <code>set_window_for_intersection</code> would fail if the pixel alignment on a vector layer was rounded unfortunately.</li> </ul>"},{"location":"changelog/#changed_9","title":"Changed","text":"<ul> <li>More documentation updates.</li> </ul>"},{"location":"changelog/#v180-2492025","title":"v1.8.0 (24/9/2025)","text":""},{"location":"changelog/#added_8","title":"Added","text":"<ul> <li>Mkdocs based documentation.</li> </ul>"},{"location":"changelog/#changed_10","title":"Changed","text":"<ul> <li>Modernised type hints to use latest Python standards.</li> </ul>"},{"location":"changelog/#v179-2392025","title":"v1.7.9 (23/9/2025)","text":""},{"location":"changelog/#fixed_11","title":"Fixed","text":"<ul> <li>Fix type inference for expressions so that <code>to_geotiff</code> selects correct GeoTIFF file type to store results as.</li> </ul>"},{"location":"changelog/#changed_11","title":"Changed","text":"<ul> <li>Improved typing of methods that take a filename to use both Path and str.</li> </ul>"},{"location":"changelog/#v178-1792025","title":"v1.7.8 (17/9/2025)","text":""},{"location":"changelog/#added_9","title":"Added","text":"<ul> <li>Added marker for mypy that Yirgacheffe has type annotations</li> </ul>"},{"location":"changelog/#v177-892025","title":"v1.7.7 (8/9/2025)","text":""},{"location":"changelog/#added_10","title":"Added","text":"<ul> <li>Automatically set rlimit for NOFILES so that parallel operations of machines with many cores don't run out of file descriptors.</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Removed internal classes <code>LayerOperation</code>, <code>LayerMathMixin</code>, and <code>LayerConstant</code> from public interface.</li> </ul>"},{"location":"changelog/#v176-2082025","title":"v1.7.6 (20/8/2025)","text":""},{"location":"changelog/#fixed_12","title":"Fixed","text":"<ul> <li>Fixed issue whereby vector layers without explicit projection would use the abstract rather than concrete area value when generating a target raster.</li> </ul>"},{"location":"changelog/#added_11","title":"Added","text":"<ul> <li>Added a core wrapper <code>constant</code> to save people using <code>ConstantLayer</code> explicitly</li> <li>Added a core wrapper <code>read_narrow_raster</code> to save people using <code>UniformAreaLayer</code> explicitly</li> </ul>"},{"location":"changelog/#v175-1982025","title":"v1.7.5 (19/8/2025)","text":""},{"location":"changelog/#changed_12","title":"Changed","text":"<ul> <li>Minor improvements to GitHub Actions workflows</li> </ul>"},{"location":"changelog/#v174-1982025","title":"v1.7.4 (19/8/2025)","text":""},{"location":"changelog/#fixed_13","title":"Fixed","text":"<ul> <li>Fixed bug whereby reads from within a single tile that has nodata values in a group layer used the wrong numpy call to check for nan.</li> </ul>"},{"location":"changelog/#added_12","title":"Added","text":"<ul> <li>Added <code>isnan</code> operator.</li> </ul>"},{"location":"changelog/#v173-1882025","title":"v1.7.3 (18/8/2025)","text":""},{"location":"changelog/#fixed_14","title":"Fixed","text":"<ul> <li>Fixed an issue introduced in 1.7.0 where <code>find_intersection</code> and <code>find_union</code> used the raw, non-pixel aligned area envelope.</li> </ul>"},{"location":"changelog/#v172-1482025","title":"v1.7.2 (14/8/2025)","text":""},{"location":"changelog/#changed_13","title":"Changed","text":"<ul> <li>Added the option to set <code>parallelism=True</code> rather than just a number when calling <code>to_geotiff</code>, allowing Yirgacheffe to select the number of CPU cores to use for parallel operations.</li> </ul>"},{"location":"changelog/#v171-1482025","title":"v1.7.1 (14/8/2025)","text":""},{"location":"changelog/#fixed_15","title":"Fixed","text":"<ul> <li>Fixed an issue whereby if you used the MLX backend and called <code>read_array</code> the return value was sometimes an mlx array rather than a numpy array.</li> </ul>"},{"location":"changelog/#v17-1482025","title":"v1.7 (14/8/2025)","text":""},{"location":"changelog/#added_13","title":"Added","text":"<ul> <li>Support the ability to create VectorLayers that don't have a pixel scale or projection added. These layers will have the correct pixel scale and projection calculated when calculations on layers are saved or aggregated based on the other raster layers used in the calculation.</li> <li>Added MapProjection object to replace PixelScale objects and projection strings being separate parameters.</li> </ul>"},{"location":"api/core/","title":"Core","text":"<p>To get started with yirgacheffe you can import data using the following core methods.</p>"},{"location":"api/core/#yirgacheffe.read_raster","title":"<code>read_raster(filename, band=1, ignore_nodata=False)</code>","text":"<p>Open a raster file (e.g., GeoTIFF).</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path | str</code> <p>Path of raster file to open.</p> required <code>band</code> <code>int</code> <p>For multi-band rasters, which band to use (defaults to first if not specified).</p> <code>1</code> <code>ignore_nodata</code> <code>bool</code> <p>If the GeoTIFF has a NODATA value, don't substitute that value for NaN.</p> <code>False</code> <p>Returns:</p> Type Description <code>YirgacheffeLayer</code> <p>An layer representing the raster data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import yirgacheffe as yg\n&gt;&gt;&gt; with yg.read_raster('test.tif') as layer:\n...     total = layer.sum()\n</code></pre>"},{"location":"api/core/#yirgacheffe.read_raster_like","title":"<code>read_raster_like(filename, like, method, band=1, ignore_nodata=False)</code>","text":"<p>Open a raster file but reproject it to match another layer.</p> <p>This method can be used to reproject a raster in one map projection to match another open layer.</p> <p>The reprojection will be only done when the data is actually used in a calculation, so unused data will not be reprojected.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path | str</code> <p>Path of raster file to open.</p> required <code>like</code> <code>YirgacheffeLayer</code> <p>Another layer that has a projection and pixel scale set. This layer will use the same projection and pixel scale as that one.</p> required <code>method</code> <code>ResamplingMethod</code> <p>The resampling method that will be used during the reprojection.</p> required <code>band</code> <code>int</code> <p>For multi-band rasters, which band to use (defaults to first if not specified).</p> <code>1</code> <code>ignore_nodata</code> <code>bool</code> <p>If the GeoTIFF has a NODATA value, don't substitute that value for NaN.</p> <code>False</code> <p>Returns:</p> Type Description <code>YirgacheffeLayer</code> <p>An layer representing the raster data in the new projection.</p> Note <p>For parallel processing, use Python's multiprocessing module. This layer is safe when used with multiprocessing, but calls to <code>read_array</code> on an object are not thread safe.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import yirgacheffe as yg\n&gt;&gt;&gt; with (\n...     yg.read_raster('map_in_esri_54009.tif') as layer1,\n...     yg.read_raster_like('map_in_wgs84.tif', layer1, yg.ResamplingMethod.Nearest) as layer2\n... ):\n...     res = layer1 * layer2\n...     res.to_geotiff('result_in_esri_54009.tif')\n</code></pre>"},{"location":"api/core/#yirgacheffe.read_shape","title":"<code>read_shape(filename, projection=None, where_filter=None, datatype=None, burn_value=1)</code>","text":"<p>Open a polygon file (e.g., GeoJSON, GPKG, or ESRI Shape File).</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path | str</code> <p>Path of vector file to open.</p> required <code>projection</code> <code>MapProjection | tuple[str, tuple[float, float]] | None</code> <p>The map projection to use.</p> <code>None</code> <code>where_filter</code> <code>str | None</code> <p>For use with files with many entries (e.g., GPKG), applies this filter to the data.</p> <code>None</code> <code>datatype</code> <code>dtype | None</code> <p>Specify the data type of the raster data generated.</p> <code>None</code> <code>burn_value</code> <code>int | float | str</code> <p>The value of each pixel in the polygon.</p> <code>1</code> <p>Returns:</p> Type Description <code>YirgacheffeLayer</code> <p>An layer representing the vector data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import yirgacheffe as yg\n&gt;&gt;&gt; with yg.read_shape('range.gpkg') as layer:\n...    ...\n</code></pre>"},{"location":"api/core/#yirgacheffe.read_shape_like","title":"<code>read_shape_like(filename, like, where_filter=None, datatype=None, burn_value=1)</code>","text":"<p>Open a polygon file (e.g., GeoJSON, GPKG, or ESRI Shape File).</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path | str</code> <p>Path of vector file to open.</p> required <code>like</code> <code>YirgacheffeLayer</code> <p>Another layer that has a projection and pixel scale set. This layer will use the same projection and pixel scale as that one.</p> required <code>where_filter</code> <code>str | None</code> <p>For use with files with many entries (e.g., GPKG), applies this filter to the data.</p> <code>None</code> <code>datatype</code> <code>dtype | None</code> <p>Specify the data type of the raster data generated.</p> <code>None</code> <code>burn_value</code> <code>int | float | str</code> <p>The value of each pixel in the polygon.</p> <code>1</code> <p>Returns:</p> Type Description <code>YirgacheffeLayer</code> <p>An layer representing the vector data.</p>"},{"location":"api/core/#yirgacheffe.read_rasters","title":"<code>read_rasters(filenames, tiled=False)</code>","text":"<p>Open a set of raster files (e.g., GeoTIFFs) as a single layer.</p> <p>Parameters:</p> Name Type Description Default <code>filenames</code> <code>Sequence[Path | str]</code> <p>List of paths of raster files to open.</p> required <code>tiled</code> <code>bool</code> <p>If you know that the rasters for a regular tileset, then setting this flag allows Yirgacheffe to perform certain optimisations that significantly improve performance for this use case.</p> <code>False</code> <p>Returns:</p> Type Description <code>YirgacheffeLayer</code> <p>An layer representing the raster data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import yirgacheffe as yg\n&gt;&gt;&gt; with yg.read_rasters(['tile_N10_E10.tif', 'tile_N20_E10.tif']) as all_tiles:\n...    ...\n</code></pre>"},{"location":"api/core/#yirgacheffe.constant","title":"<code>constant(value)</code>","text":"<p>Generate a layer that has the same value in all pixels regardless of scale, projection, and area.</p> <p>Generally this should not be necessary unless you must have the constant as the first term in an expression, as Yirgacheffe will automatically convert numbers into constant layers. However if the constant is the first term in the expression it must be wrapped by this call otherwise Python will not know that it should be part of the Yirgacheffe expression.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int | float</code> <p>The value to be in each pixel of the expression term.</p> required <p>Returns:</p> Type Description <code>YirgacheffeLayer</code> <p>A constant layer of the provided value.</p>"},{"location":"api/core/#yirgacheffe.from_array","title":"<code>from_array(values, origin, projection)</code>","text":"<p>Creates an in-memory layer from a numerical array.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>ndarray</code> <p>a 2D array of data values, with Y on the first dimension, X on the second dimension.</p> required <code>origin</code> <code>tuple[float, float]</code> <p>the position of the top left pixel in the geospatial space</p> required <code>projection</code> <code>MapProjection | tuple[str, tuple[float, float]]</code> <p>the map projection and pixel scale to use.</p> required <p>Returns:</p> Type Description <code>YirgacheffeLayer</code> <p>A geospatial layer that uses the provided data for its values.</p>"},{"location":"api/expressions/","title":"Expressions","text":"<p>The power of Yirgacheffe comes from being able to operate on geospatial data as if it was an elemental type. You can combine and work with layers without worrying about individual pixels or how different layers are aligned spatially. Assuming your data is in the same projection and pixel scale, you can just get on working. For example, here's how a simple Area of Habitat calculation might be implemented:</p> <pre><code>import yirgaceffe as yg\n\nwith (\n    yg.read_raster(\"habitats.tif\") as habitat_map,\n    yg.read_raster('elevation.tif') as elevation_map,\n    yg.read_shape('species123.geojson') as range_polygon\n):\n    refined_habitat = habitat_map.isin([...species habitat codes...])\n    refined_elevation = (elevation_map &gt;= species_min) &amp; (elevation_map &lt;= species_max)\n    aoh = refined_habitat * refined_elevation * range_polygon\n    print(f'area for species 123: {aoh.sum()}')\n    aoh.to_geotiff(\"result.tif\")\n</code></pre>"},{"location":"api/expressions/#operators","title":"Operators","text":""},{"location":"api/expressions/#add-subtract-multiple-divide","title":"Add, subtract, multiple, divide","text":"<p>Pixel-wise addition, subtraction, multiplication or division (both true and floor division), and remainder. Either between arrays, or with constants:</p> <pre><code>with (\n    yg.read_raster('test1.tif') as layer1,\n    yg.read_raster('test2.tif') as layer2\n):\n    result = layer1 + layer2\n    result.to_geotiff(\"result.tif\")\n</code></pre> <p>or</p> <pre><code>with yg.read_raster('test1.tif') as layer1:\n    result = layer1 * 42.0\n    result.to_geotiff(\"result.tif\")\n</code></pre>"},{"location":"api/expressions/#boolean-testing","title":"Boolean testing","text":"<p>Testing for equality, less than, less than or equal, greater than, and greater than or equal are supported on layers, along with logical or and logical and, as per this example, where <code>elevation_upper</code> and <code>elevation_lower</code> are scalar values:</p> <pre><code>filtered_elevation = (min_elevation_map &lt;= elevation_upper) &amp; (max_elevation_map &gt;= elevation_lower)\n</code></pre>"},{"location":"api/expressions/#power","title":"Power","text":"<p>Pixel-wise raising to a constant power:</p> <pre><code>with yg.read_raster('test1.tif') as layer1:\n    calc = layer1 ** 0.65\n    calc.save(\"result.tif\")\n</code></pre>"},{"location":"api/expressions/#log-exp-clip-etc","title":"Log, Exp, Clip, etc.","text":"<p>The following math operators common to numpy and other libraries are currently supported:</p> <ul> <li>abs</li> <li>all</li> <li>any</li> <li>ceil</li> <li>clip</li> <li>exp</li> <li>exp2</li> <li>floor</li> <li>isin</li> <li>log</li> <li>log2</li> <li>log10</li> <li>maximum</li> <li>minimum</li> <li>nan_to_num</li> <li>round</li> <li>sum</li> </ul> <p>Typically these can be invoked either on a layer as a method:</p> <pre><code>calc = layer1.log10()\n</code></pre> <p>Or via the operators module, as it's sometimes nicer to do it this way when chaining together operations in a single expression:</p> <pre><code>import yirgaceffe.operators as yo\n\ncalc = yo.log10(layer1 / layer2)\n</code></pre>"},{"location":"api/expressions/#2d-matrix-convolution","title":"2D matrix convolution","text":"<p>To facilitate image processing algorithms you can supply a weight matrix to generate a processed image. Currently this support only works for square weight matrices of an odd size.</p> <p>For example, to apply a blur function to a raster:</p> <pre><code>blur_filter = np.array([\n    [0.0, 0.1, 0.0],\n    [0.1, 0.6, 0.1],\n    [0.0, 0.1, 0.0],\n])\nwith yg.read_raster('original.tif') as layer1:\n    calc = layer1.conv2d(blur_filter)\n    calc.to_geotiff(\"blurred.tif\")\n</code></pre>"},{"location":"api/expressions/#type-conversion","title":"Type conversion","text":"<p>Similar to numpy and other Python numerical libraries, Yirgacheffe will automatically deal with simple type conversion where possible, however sometimes explicit conversion is either necessary or desired. Similar to numpy, there is an <code>astype</code> operator that lets you set the conversion:</p> <pre><code>from yirgacheffe.operations import DataType\n\n\nwith yg.read_raster('float_data.tif') as float_layer:\n    int_layer = float_layer.astype(DataType.Int32)\n</code></pre>"},{"location":"api/expressions/#apply","title":"Apply","text":"<p>You can specify a function that takes either data from one layer or from two layers, and returns the processed data. There's two version of this: one that lets you specify a numpy function that'll be applied to the layer data as an array, or one that is more shader like that lets you do pixel wise processing.</p> <p>Firstly the numpy version looks like this:</p> <pre><code>def is_over_ten(input_array):\n    return numpy.where(input_array &gt; 10.0, 0.0, 1.0)\n\nwith yg.read_raster(\"test1.tif\") as layer1:\n    calc = layer1.numpy_apply(is_over_ten)\n    calc.to_geotiff(\"result.tif\")\n</code></pre> <p>or</p> <pre><code>def simple_add(first_array, second_array):\n    return first_array + second_array\n\nwith (\n    yg.read_raster(\"test1.tif\") as layer1,\n    yg.read_raster(\"test2.tif\") as layer2\n):\n    calc = layer1.numpy_apply(simple_add, layer2)\n    calc.to_geotiff(\"result.tif\")\n</code></pre> <p>If you want to do something specific on the pixel level, then you can also do that, again either on a unary or binary form.</p> <pre><code>def is_over_ten(input_pixel):\n    return 1.0 if input_pixel &gt; 10 else 0.0\n\nwith yg.read_raster(\"test1.tif\") as layer1:\n    calc = layer1.shader_apply(is_over_ten)\n    calc.to_geotiff(result)\n</code></pre> <p>Note:</p> <ol> <li>Using <code>numpy_apply</code> prevents GPU optimisations occuring, so should be used as a last resort.</li> <li>In general <code>numpy_apply</code> is considerably faster than <code>shader_apply</code>.</li> </ol>"},{"location":"api/expressions/#storing-the-results-of-expressions","title":"Storing the results of expressions","text":"<p>There are three ways to store the result of a computation.</p>"},{"location":"api/expressions/#saving-to-a-geotiff","title":"Saving to a GeoTIFF","text":"<p>In all the above examples we use the <code>to_geotiff</code> call, to which you pass a filename for a GeoTIFF, into which the results will be written. You can optionally pass a callback to save which will be called for each chunk of data processed and give you the amount of progress made so far as a number between 0.0 and 1.0:</p> <pre><code>def print_progress(p)\n    print(f\"We have made {p * 100} percent progress\")\n\n...\n\ncalc.to_geotiff(result, callback=print_progress)\n</code></pre>"},{"location":"api/expressions/#aggregations","title":"Aggregations","text":"<p>The alternative is to call aggregation functions such as <code>sum</code>, <code>min</code>, or <code>max</code> which will give you a single value by aggregating the data within the layer or expression:</p> <pre><code>with (\n    RasterLayer.layer_from_file(...) as area_layer,\n    VectorLayer(...) as mask_layer\n):\n    intersection = RasterLayer.find_intersection([area_layer, mask_layer])\n    area_layer.set_intersection_window(intersection)\n    mask_layer.set_intersection_window(intersection)\n\n    calc = area_layer * mask_layer\n\n    total_area = calc.sum()\n</code></pre>"},{"location":"api/expressions/#as-numpy-arrays","title":"As numpy arrays","text":"<p>Finally, if you want to read the pixel values of either a layer or an expression, you can call <code>read_array</code>:</p> <pre><code>import yirgacheffe as yg\n\nwith (\n    yg.read_raster(\"test1.tif\") as layer1,\n    yg.read_raster(\"test2.tif\") as layer2\n):\n    result = layer1 + layer2\n    pixels = result.read_array(10, 10, 100, 100)\n</code></pre>"},{"location":"api/layer/","title":"YirgacheffeLayer","text":"<p>A layer object represents some geospatial data. This might come from:</p> <ul> <li>A raster data source, for example, data from a GeoTIFF</li> <li>A polygon data source, for example, data from a GPKG, GeoJSON, or ESRI Shapefile</li> <li>A constant value</li> <li>An expression built up using the above inputs using operators to add, divide, etc.</li> </ul>"},{"location":"api/layer/#yirgacheffe.YirgacheffeLayer","title":"<code>yirgacheffe.YirgacheffeLayer</code>","text":"<p>The common base class for the different layer types. Most still inherit from RasterLayer as deep down they end up as pixels, but this is a start to make other layers that don't need to rasterize not have to carry all that baggage.</p>"},{"location":"api/layer/#yirgacheffe.YirgacheffeLayer.area","title":"<code>area</code>  <code>property</code>","text":"<p>Returns the geospatial <code>Area</code> of the layer.</p>"},{"location":"api/layer/#yirgacheffe.YirgacheffeLayer.datatype","title":"<code>datatype</code>  <code>property</code>","text":"<p>Returns the <code>DataType</code> of the pixels within a layer.</p>"},{"location":"api/layer/#yirgacheffe.YirgacheffeLayer.map_projection","title":"<code>map_projection</code>  <code>property</code>","text":"<p>Returns the <code>MapProjection</code> (projection name and pixel size) of the layer.</p>"},{"location":"api/layer/#yirgacheffe.YirgacheffeLayer.latlng_for_pixel","title":"<code>latlng_for_pixel(x, y)</code>","text":"<p>Get geo coords for pixel. This is relative to the set view window.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>X axis position within raster</p> required <code>y</code> <code>int</code> <p>Y axis position within raster</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>A tuple containing the (latitude, longitude).</p>"},{"location":"api/layer/#yirgacheffe.YirgacheffeLayer.pixel_for_latlng","title":"<code>pixel_for_latlng(lat, lng)</code>","text":"<p>Get pixel for geo coords. This is relative to the set view window. Result is rounded down to nearest pixel.</p> <p>Parameters:</p> Name Type Description Default <code>lat</code> <code>float</code> <p>Geospatial latitude in WGS84</p> required <code>lng</code> <code>float</code> <p>Geospatial longitude in WGS84</p> required <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>A tuple containing the x, y coordinates in pixel space.</p>"},{"location":"api/layer/#yirgacheffe.YirgacheffeLayer.read_array","title":"<code>read_array(x, y, width, height)</code>","text":"<p>Reads data from the layer based on the current reference window.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>X axis offset for reading</p> required <code>y</code> <code>int</code> <p>Y axis offset for reading</p> required <code>width</code> <code>int</code> <p>Width of data to read</p> required <code>height</code> <code>int</code> <p>Height of data to read</p> required <p>Returns:</p> Type Description <code>Any</code> <p>An array of values from the layer.</p>"},{"location":"api/layer/#yirgacheffe.YirgacheffeLayer.show","title":"<code>show(ax=None, max_pixels=1000, **kwargs)</code>","text":"<p>Display data using matplotlib.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <p>Matplotlib axes object. If not provided, the default matplotlib context will be used.</p> <code>None</code> <code>max_pixels</code> <code>int | None</code> <p>How many pixels to downsample to. If None, raw pixels will be used.</p> <code>1000</code> <code>**kwargs</code> <p>Passed to matplotlib imshow.</p> <code>{}</code> <p>Returns:</p> Type Description <p>A matplotlib image.</p>"},{"location":"api/layer/#yirgacheffe.YirgacheffeLayer.to_geotiff","title":"<code>to_geotiff(filename, and_sum=False, parallelism=None, callback=None, nodata=None, sparse=False)</code>","text":"<p>Saves a calculation to a raster file, optionally also returning the sum of pixels.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path | str</code> <p>Path of the raster to save the result to.</p> required <code>and_sum</code> <code>bool</code> <p>If true then the function will also calculate the sum of the raster as it goes and return that value.</p> <code>False</code> <code>parallelism</code> <code>int | bool | None</code> <p>If passed, attempt to use multiple CPU cores up to the number provided, or if set to True, yirgacheffe will pick a sensible value.</p> <code>None</code> <code>callback</code> <code>Callable[[float], None] | None</code> <p>If passed, this callback will be called periodically with a progress update for the saving, with a value between 0.0 and 1.0.</p> <code>None</code> <code>nodata</code> <code>float | int | None</code> <p>Nominate a value to be stored as nodata in the result.</p> <code>None</code> <code>sparse</code> <code>bool</code> <p>If True then save a sparse GeoTIFF as per GDAL's extension to the GeoTIFF standard.</p> <code>False</code> <p>Returns:</p> Type Description <code>float | None</code> <p>Either returns None, or the sum of the pixels in the resulting raster if <code>and_sum</code> was specified.</p>"},{"location":"api/operators/","title":"Operators","text":"<p>The following symbolic operators are supported on layers:</p> Symbol Operator + add - subtract * multiply / division // floor division % mod ^ power == equal != not equal &lt; less than &lt;= less than or equal &gt; greater than &gt;= greater than or equal &amp; logical and | logical or <p>On a layer you can also invoke the following operations using <code>layer.operator(...)</code> syntax:</p> Operator abs ceil clip conv2d exp exp2 floor isin isnan log log10 log2 nan_to_num <p>You can also call the following methods from <code>yirgacheffe</code>:</p>"},{"location":"api/operators/#yirgacheffe.abs","title":"<code>abs = LayerOperation.abs</code>  <code>module-attribute</code>","text":""},{"location":"api/operators/#yirgacheffe.ceil","title":"<code>ceil = LayerOperation.ceil</code>  <code>module-attribute</code>","text":""},{"location":"api/operators/#yirgacheffe.exp","title":"<code>exp = LayerOperation.exp</code>  <code>module-attribute</code>","text":""},{"location":"api/operators/#yirgacheffe.exp2","title":"<code>exp2 = LayerOperation.exp2</code>  <code>module-attribute</code>","text":""},{"location":"api/operators/#yirgacheffe.floor","title":"<code>floor = LayerOperation.floor</code>  <code>module-attribute</code>","text":""},{"location":"api/operators/#yirgacheffe.isin","title":"<code>isin = LayerOperation.isin</code>  <code>module-attribute</code>","text":""},{"location":"api/operators/#yirgacheffe.log","title":"<code>log = LayerOperation.log</code>  <code>module-attribute</code>","text":""},{"location":"api/operators/#yirgacheffe.log10","title":"<code>log10 = LayerOperation.log10</code>  <code>module-attribute</code>","text":""},{"location":"api/operators/#yirgacheffe.log2","title":"<code>log2 = LayerOperation.log2</code>  <code>module-attribute</code>","text":""},{"location":"api/operators/#yirgacheffe.nan_to_num","title":"<code>nan_to_num = LayerOperation.nan_to_num</code>  <code>module-attribute</code>","text":""},{"location":"api/operators/#yirgacheffe.round","title":"<code>round = LayerOperation.round</code>  <code>module-attribute</code>","text":""},{"location":"api/operators/#yirgacheffe.all","title":"<code>all(layers)</code>","text":"<p>Combine layers with AND operation.</p> <p>Returns a raster where each pixel is 1 only if ALL input layers have non-zero values at that geospatial location.</p> <p>Similar to Python's built-in all() but for Yirgacheffe layers.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list</code> <p>List/sequence of layers to AND</p> required <p>Returns:</p> Type Description <p>A new raster layer with pixel-wise sums</p>"},{"location":"api/operators/#yirgacheffe.any","title":"<code>any(layers)</code>","text":"<p>Combine layers with OR operation.</p> <p>Returns a raster where each pixel is 1 if ANY input layers has a non-zero value at that geospatial location.</p> <p>Similar to Python's built-in any() but for Yirgacheffe layers.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list</code> <p>List/sequence of layers to OR</p> required <p>Returns:</p> Type Description <p>A new raster layer with pixel-wise sums</p>"},{"location":"api/operators/#yirgacheffe.maximum","title":"<code>maximum(a, b)</code>","text":"<p>Element-wise maximum of layer elements.</p> <p>Behaves like numpy.maximum(x1, x2), comparing two layers element-by-element and returning a new layer with the maximum values.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <p>First layer or constant to compare.</p> required <code>b</code> <p>Second layer or constant to compare.</p> required <p>Returns:</p> Type Description <p>New layer representing the element-wise maximum of the inputs.</p>"},{"location":"api/operators/#yirgacheffe.minimum","title":"<code>minimum(a, b)</code>","text":"<p>Element-wise minimum of layer elements.</p> <p>Behaves like numpy.minimum(x1, x2), comparing two layers element-by-element and returning a new layer with the minimum values.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <p>First layer or constant to compare.</p> required <code>b</code> <p>Second layer or constant to compare.</p> required <p>Returns:</p> Type Description <p>New layer representing the element-wise minimum of the inputs.</p>"},{"location":"api/operators/#yirgacheffe.sum","title":"<code>sum(layers)</code>","text":"<p>Combine multiple layers by summing spatially corresponding pixels.</p> <p>Creates a new raster where each pixel is the sum of that pixel's values across all input rasters for the same location.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list</code> <p>List/sequence of layers to sum</p> required <p>Returns:</p> Type Description <p>A new raster layer with pixel-wise sums</p> <p>Examples:</p>"},{"location":"api/operators/#yirgacheffe.sum--combine-100-species-habitat-rasters-into-richness-map","title":"Combine 100 species habitat rasters into richness map","text":"<p>richness = yg.sum(habitat_layers)</p> Note <p>To sum all pixels within a single raster to get a scalar, use the .sum() method instead: <code>layer.sum()</code></p>"},{"location":"api/operators/#yirgacheffe.where","title":"<code>where(cond, a, b)</code>","text":"<p>Return elements chosen from <code>a</code> or <code>b</code> depending on <code>cond</code>.</p> <p>Behaves like numpy.where(condition, x, y), returning a layer operation where elements from <code>a</code> are selected where <code>cond</code> is True, and elements from <code>b</code> are selected where <code>cond</code> is False.</p> <p>Parameters:</p> Name Type Description Default <code>cond</code> <p>Layer or constant used as condition. Where True, yield <code>a</code>, otherwise yield <code>b</code>.</p> required <code>a</code> <p>Layer or constant with values from which to choose where <code>cond</code> is True.</p> required <code>b</code> <p>Layer or constant with values from which to choose where <code>cond</code> is False.</p> required <p>Returns:</p> Type Description <p>New layer representing the conditional selection.</p>"},{"location":"api/classes/area/","title":"<code>Area</code>","text":"<p>Class to hold a geospatial area. Can optionally have a projection associated.</p> <p>Ideally areas should always have a projection associated with them, however some data sources, notably polygon datasets like GeoJSON, do not store this, so we have to allow for projectionless areas.</p> <p>You can use set operators | (union) and &amp; (intersection) on Areas.</p> <p>If two areas are intersected or unioned and they have the same map projection and geospatial pixel size, but they do not perfectly align on the same pixel grid, then the operation will be performed based on nearest neighbour alignment of the pixel grids, such that the resulting area is still pixel aligned.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>float</code> <p>Left most point in the projection space.</p> required <code>top</code> <code>float</code> <p>Top most point in the projection space.</p> required <code>right</code> <code>float</code> <p>Right most point in the projection space.</p> required <code>bottom</code> <code>float</code> <p>Bottom most point in the projection space.</p> required <code>projection</code> <code>MapProjection | None</code> <p>An optional map projection.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>left</code> <code>float</code> <p>Left most point in the projection space.</p> <code>top</code> <code>float</code> <p>Top most point in the projection space.</p> <code>right</code> <code>float</code> <p>Right most point in the projection space.</p> <code>bottom</code> <code>float</code> <p>Bottom most point in the projection space.</p> <code>projection</code> <code>MapProjection | None</code> <p>An optional map projection.</p>"},{"location":"api/classes/area/#yirgacheffe.Area.geo_transform","title":"<code>geo_transform</code>  <code>property</code>","text":"<p>Returns the GDAL geo transform for the area.and()</p> <p>Attempts to call this on an area with no projection will raise a ValueError.</p> <p>Returns:</p> Type Description <code>tuple[float, float, float, float, float, float]</code> <p>A tuple of floats for the GDAL geo transform record.</p>"},{"location":"api/classes/area/#yirgacheffe.Area.is_world","title":"<code>is_world</code>  <code>property</code>","text":"<p>Returns true if this is a global area, independent of projection.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the Area was created with <code>world</code> otherwise False.</p>"},{"location":"api/classes/area/#yirgacheffe.Area.pixel_dimensions","title":"<code>pixel_dimensions</code>  <code>property</code>","text":"<p>Returns the size in pixels for this area in its given projection.</p> <p>Attempts to call this on an area with no projection will raise a ValueError.</p> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>A tuple of the width and height.</p>"},{"location":"api/classes/area/#yirgacheffe.Area.grow","title":"<code>grow(offset)</code>","text":"<p>Expand the area in all directions by the given amount.</p> <p>Generates a new area that is an expanded version of the current area.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>float</code> <p>The amount by which to grow the area.</p> required <p>Returns:</p> Type Description <code>Area</code> <p>A new area of the expanded size.</p>"},{"location":"api/classes/area/#yirgacheffe.Area.overlaps","title":"<code>overlaps(other)</code>","text":"<p>Check if this area overlaps with another area.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Area</code> <p>The other area to compare this area with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the two areas intersect, otherwise false.</p>"},{"location":"api/classes/area/#yirgacheffe.Area.project_like","title":"<code>project_like(other)</code>","text":"<p>Takes a projectionless area and maps it onto a map projection based on an existing area.</p> <p>Because map projections have pixel scales associated with them, the area may be expanded to ensure that the original area is within the bounds when mapped to the pixel space of the other area.</p> <p>Will raise an exception if this area already has a map projection set, or if the other area does not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Area</code> <p>The other area to take the map projection from.</p> required <p>Returns:</p> Type Description <code>Area</code> <p>A new area with the projection map.</p>"},{"location":"api/classes/area/#yirgacheffe.Area.reproject","title":"<code>reproject(target_projection)</code>","text":"<p>Takes an area and projects it.</p>"},{"location":"api/classes/area/#yirgacheffe.Area.world","title":"<code>world()</code>  <code>staticmethod</code>","text":"<p>Creates an area that covers the entire planet.</p> <p>Returns:</p> Type Description <code>Area</code> <p>An area where the extents are nan, but is_world returns true.</p>"},{"location":"api/classes/mapprojection/","title":"<code>MapProjection</code>","text":"<p>Records the map projection and the size of the pixels in a layer.</p> <p>Note: It is very common to find that round errors creep into pixel scale values in GeoTIFFs from different sources, and so MapProjection tolerates small amounts of difference between pixel scales that are below a single metre in resolution.</p> <p>This superceeeds the old PixelScale class, which will be removed in version 2.0.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>The map projection used in WKT format, or as \"epsg:xxxx\" or \"esri:xxxx\".</p> required <code>xstep</code> <code>float</code> <p>The number of units horizontal distance a step of one pixel makes in the map projection.</p> required <code>ystep</code> <code>float</code> <p>The number of units vertical distance a step of one pixel makes in the map projection.</p> required <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The map projection used in WKT format.</p> <code>xstep</code> <p>The number of units horizontal distance a step of one pixel makes in the map projection.</p> <code>ystep</code> <p>The number of units vertical distance a step of one pixel makes in the map projection.</p> <p>Examples:</p> <p>Create a map projection using an EPSG code:</p> <pre><code>&gt;&gt;&gt; proj_wgs84 = MapProjection(\"epsg:4326\", 0.001, -0.001)\n</code></pre> <p>Create a projection using an ESRI code:</p> <pre><code>&gt;&gt;&gt; proj_esri = MapProjection(\"esri:54030\", 1000, -1000)\n</code></pre>"},{"location":"api/classes/mapprojection/#yirgacheffe.MapProjection.round_up_pixels","title":"<code>round_up_pixels(x, y)</code>","text":"<p>In general we round up pixels, as we don't want to lose range data, but floating point math means we will get errors where the value of pixel scale value rounds us to a tiny faction of a pixel up, and so math.ceil would round us up for microns worth of distance.</p>"},{"location":"api/classes/window/","title":"<code>Window</code>","text":"<p>Class to hold the pixel dimensions of data in the given projection.</p> <p>Parameters:</p> Name Type Description Default <code>xoff</code> <code>int</code> <p>X axis offset.</p> required <code>yoff</code> <code>int</code> <p>Y axis offset.</p> required <code>xsize</code> <code>int</code> <p>Width of data in pixels.</p> required <code>ysize</code> <code>int</code> <p>Height of data in pixels.</p> required <p>Attributes:</p> Name Type Description <code>xoff</code> <code>int</code> <p>X axis offset.</p> <code>yoff</code> <code>int</code> <p>Y axis offset.</p> <code>xsize</code> <code>int</code> <p>Width of data in pixels.</p> <code>ysize</code> <code>int</code> <p>Height of data in pixels.</p>"},{"location":"api/classes/window/#yirgacheffe.Window.as_array_args","title":"<code>as_array_args</code>  <code>property</code>","text":"<p>A tuple containing xoff, yoff, xsize, and ysize.</p>"},{"location":"api/classes/window/#yirgacheffe.Window.grow","title":"<code>grow(pixels)</code>","text":"<p>Expand the area in all directions by the given amount.</p> <p>Generates a new window that is an expanded version of the current window.</p> <p>Parameters:</p> Name Type Description Default <code>pixels</code> <code>int</code> <p>The amount by which to grow the window in pixels.</p> required <p>Returns:</p> Type Description <code>Window</code> <p>A new window of the expanded size.</p>"},{"location":"api/enums/datatype/","title":"DataType","text":"<p>               Bases: <code>Enum</code></p> <p>Represents the type of data returned by a layer.</p> <p>This enumeration defines the valid data types supported by Yirgacheffe, and is what is returned by  calling <code>datatype</code> on a layer or expression, and can be passed to <code>astype</code> to convert values between types.</p> <p>Attributes:</p> Name Type Description <code>Float32</code> <p>32 bit floating point value</p> <code>Float64</code> <p>64 bit floating point value</p> <code>Byte</code> <p>Unsigned 8 bit integer value</p> <code>Int8</code> <p>Signed 8 bit integer value</p> <code>Int16</code> <p>Signed 16 bit integer value</p> <code>Int32</code> <p>Signed 32 bit integer value</p> <code>Int64</code> <p>Signed 64 bit integer value</p> <code>UInt8</code> <p>Unsigned 8 bit integer value</p> <code>UInt16</code> <p>Unsigned 16 bit integer value</p> <code>UInt32</code> <p>Unsigned 32 bit integer value</p> <code>UInt64</code> <p>Unsigned 64 bit integer value</p>"},{"location":"api/enums/datatype/#yirgacheffe.DataType.of_array","title":"<code>of_array(val)</code>  <code>classmethod</code>","text":"<p>Generates the Yirgacheffe data type value from a numpy array.</p> <p>Returns:</p> Type Description <code>dtype</code> <p>A Yirgacheffe data type value.</p>"},{"location":"api/enums/datatype/#yirgacheffe.DataType.of_gdal","title":"<code>of_gdal(val)</code>  <code>classmethod</code>","text":"<p>Generates the Yirgacheffe data type value from the correspondiong GDAL value.</p> <p>Returns:</p> Type Description <code>dtype</code> <p>A Yirgacheffe data type value.</p>"},{"location":"api/enums/datatype/#yirgacheffe.DataType.sizeof","title":"<code>sizeof()</code>","text":"<p>Returns the number of bytes used to store the data type.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes used to store the data type.</p>"},{"location":"api/enums/datatype/#yirgacheffe.DataType.to_gdal","title":"<code>to_gdal()</code>","text":"<p>Coverts the Yirgacheffe data type to the corresponding GDAL constant.</p> <p>Returns:</p> Type Description <code>int</code> <p>An integer with the corresponding GDAL type constant.</p>"},{"location":"api/enums/resamplingmethods/","title":"ResamplingMethod","text":"<p>               Bases: <code>Enum</code></p> <p>Resampling methods used in reprojecting rasters.</p> <p>This enumeration defines the resampling methods supported by Yirgacheffe.</p> <p>Attributes:</p> Name Type Description <code>Average</code> <p>Computes the average of all non-NODATA contributing pixels</p> <code>Max</code> <p>Selects the maximum value among all non-NODATA contributing pixels</p> <code>Med</code> <p>Computes the median of all non-NODATA contributing pixels</p> <code>Min</code> <p>Selects the minimum value among all non-NODATA contributing pixels</p> <code>Mode</code> <p>Selects the most frequently occurring value among contributing pixels</p> <code>Nearest</code> <p>Uses nearest-neighbor sampling (no interpolation)</p> <code>RootMeanSquare</code> <p>Computes the root mean square of all non-NODATA contributing pixels</p>"}]}